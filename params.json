{"name":"Promises.GitHub.io","tagline":"JavaScript Promises Tutorial","body":"EcmaScript6 has introduced a native Promises spec which \"promises\" to make asynchronous chaining much simpler.\r\n\r\nPromises are a new pattern to handle asynchronous JavaScript functions. They provide a way of chaining multiple asynchronous functions that allows them to operate sequentially and pass values to each other. This means that each function will wait for the previous function to pass a value and then can operate on that value.\r\n\r\nThis is a relatively new pattern and might not work out of the box on older browsers.\r\n[Browser Compatability](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#AutoCompatibilityTable)\r\n\r\nDespite the simplicity of the Promise pattern I've found that the descriptions and numerous tutorials on the web to be insufficient for completely grasping the concept. One of the failings I have observed is the general attempt to learn Javascript patterns with contrived examples.\r\n\r\nInstead I am going illustrate a solution to an actual problem: capturing the latitude and longitude of a broswer with the [HTML5 Geolocation Api](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) and then turning that into a physical address. If you are already familiar with asynchronous JavaScript code feel free to skip to the [Promises](#promises) section.\r\n\r\n* [Getting Started](#getting_started)\r\n* [Synchronous Code](#synchronous_code)\r\n* [Asynchronous Code](#asynchronous_code)\r\n* [Promises](#promises)\r\n* [Geolocation Method](#geolocation_method)\r\n* [Geolocation Promise](#geolocation_as_promise)\r\n* [Reverse Geocoding](#reverse_geocoding)\r\n## Getting Started\r\n\r\nYou can checkout my [Github repo](https://github.com/Lyonsclay/Promises-Promises.git) it has all the function defintions for this tutorial. I've included a simple ruby server that will become necessary when the HTML5 geolocation feature is used.\r\n\r\n## Synchronous Code\r\n\r\nA typical javascript function definition is an example of synchronous code. Synchronous code is run sequentially from one line to the next and blocks execution of further tasks until the present routine is complete. Synchronous code can return a value to the function caller with the `return` statement.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction output(value) {\r\n    return value;\r\n}\r\n\r\nvar sync = output('jumbalaya');\r\nconsole.log(sync === 'jumbalaya');   // true\r\n</pre>\r\n\r\n## Asynchronous Code\r\n\r\nNow let's look at an asynchronous function using [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout) as the example. With an asynchronous function you can't capture the output directly with a return statement.\r\n\r\n<pre class=\"prettyprint\">\r\nvar async = setTimeout(function () {\r\n    console.log('stay classy');\r\n    return 'to the depths';\r\n}, 1500);\r\n\r\nconsole.log(async === 'to the depths');   // false\r\n</pre>\r\n\r\nThe return statement inside the `setTimeout` is actually ignored and `async` is set to equal the numerical id of the timeout. This id can then be used with the `clearTimeout` function to end an active `setTimeout`timer.\r\n\r\nOne way of capturing a value from a `setTimeout` is to define a global variable so that all functions can access it.\r\n\r\n<pre class=\"prettyprint\">\r\nvar deffered = 'bric a brac';   // global variable\r\nvar passingOut = setTimeout(function () {\r\n    deffered = 'captured value';\r\n    console.log('check deffered now');\r\n}, 3000);\r\n\r\nconsole.log(deffered === \"captured value\");    //false\r\n</pre>\r\n\r\nThe global variable can also be set inside a function.[window](https://developer.mozilla.org/en-US/docs/Web/API/Window)\r\n\r\n<pre class=\"prettyprint\">\r\nfunction setGlobal () {\r\n    window.greeting = 'namaste';\r\n}\r\n</pre>\r\n\r\nEither way it is declared a global variable refers to a variable in the [global execution context](http://www.ecma-international.org/ecma-262/5.1/#sec-10.2.3) which means that all functions declared in the immediate scope and it's descendants have access to a global variable.\r\n\r\nSynchronous functions can be chained together so that the output of one function is the input of the next. This works because all functions declared inside an outer function have access to it's variables.[scope](http://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/)\r\n\r\n<pre class=\"prettyprint\">\r\n'run'.concat(' away').bold(); // <b>run away</b>\r\n</pre>\r\n\r\nTo chain asynchronous functions together they have to be nested so that they are forced to operate in sequence.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction chains() {\r\n    var arcane = 'chains';\r\n    setTimeout(function () {        // outer function\r\n        arcane += ' of ';\r\n        setTimeout(function () {    // inner function\r\n            arcane += 'mephistopheles';\r\n            console.log(arcane)\r\n        }, 700);\r\n    }, 700);\r\n    return arcane;\r\n}\r\n</pre>\r\n\r\nThe execution of each nested asynchronous function is contingent upon the completion of an event called by the outer function that encompasses it. In the above case that event is a delay of 700 milliseconds. As with any function the code encapsulated executes sequentially. By nesting a function we wait for the outer function to complete before executing the lines of code in the inner function.\r\n\r\nIf we set a variable equal to the output of the function `chains` that variable will still have the value given in the initial declaration `var arcane = \"chains\"`. Each time an asynchronous function like `setTimeout` is called it gets processed in it's own time and doesn't block subsequent code. That means that the value for `arcane` has returned before the functions passed to the `setTimeout`s adds the text \"of\" and \"mephistopheles\" respectively to `arcane`.\r\n\r\n##Promises\r\n\r\nThe native EcmaScript6 Promise is based off of the [Promises/A+](https://promisesaplus.com) proposal which has a nice clear specification that is worth checking out.\r\n\r\nHere is a simple promise to illustrate the pattern.\r\n\r\n<pre class=\"prettyprint\">\r\nvar basicPromise = new Promise(function (resolve, reject) {\r\n\t\tvar basicOperation = true;\r\n    if (basicOperation) {\r\n        resolve(\"play to win\");\r\n    } else {\r\n        reject(\"crash and burn\");\r\n    }\r\n});\r\n</pre>\r\n\r\nIf you enter `basicPromise` in the console you will see what a Promise object looks like and what value it has resolved to.\r\n\r\nIf you get an error stateing that Promise is not defined your browser may not support Promises( currently no version of IE does). Consider updating your browser or include the polyfill recommended by [Forbes Lindesay](https://www.promisejs.org).\r\n\r\n<pre class=\"prettyprint\">\r\nbasicPromise // Promise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: \"play to win\"}\r\n</pre>\r\n\r\nA promise takes a function with two arguments, which by convention are \"resolve\" and \"reject\". These names can be anything, but it's better to stick with convention. Inside the function body will live the core operations of the Promise, in this case it is simply setting the variable `basicOperation` to `true`. After the core operations are concluded you are responsible for calling \"resolve\" or \"reject\", otherwise the Promise will forever have the status of \"pending\". Both \"resolve\" and \"reject\" take an argument which can be any object that then becomes the PromiseValue. It's important to note that while you can name \"resolve\" and \"reject\" anything you want these are not functions you define, but are rather functions defined on the Promise prototype that you call with arguments that you provide.\r\n\r\nA promise can be \"pending\", \"resolved\", or \"rejected\". Once a Promise has resolved it's state to \"resolved\" or \"rejected\" it never changes status after that. If you want to invoke the same operation multiple times and use the Promise pattern then just return a Promise from a function.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction evenOdds() {\r\n    return new Promise(function (resolve, reject) {\r\n        if (Math.random() > .5) {\r\n            resolve('beautiful');\r\n        } else {\r\n            reject('horrific')\r\n        }\r\n    });\r\n}\r\n</pre>\r\n\r\nIf you enter `evenOdds();` multiple times in the console the `PromiseValue`will equal \"resolve\" or \"reject\" randomly. Now let's say we want to pass the `PromiseValue` to a function that does something with it's value. For that we are provided with a `then` method that allows us to chain functions so that they perform sequentially and are able to pass values to subsquent functions.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction get(value) {\r\n\tconsole.log('everything is ' + value);\r\n}\r\n\r\nfunction throwOut(value) {\r\n\tconsole.log('so wrong ' + value);\r\n}\r\n\r\nevenOdds().then(get, throwOut);\r\n</pre>\r\n\r\nTry entering `evenOdds().then(get, throwOut);` multiple times and you will observe the value geting passed randomly to `get` or `throwOut`.\r\n\r\nAccording to the [Promises A+]() specification the `then` method receives two arguments that are ignored if they are not functions. The `then` method passes the `promiseValue` to the first function if it is resolved or the second method if the promise has rejected.\r\n\r\nThe term 'thenable' refers to an object or function that has a `then` method. This is the most essential characteristic of a Promise and is what allows for Promises of different libraries to interact. There is some speculation that JavaScript asynchronous functions that are currently using the Callback pattern will be adapted to the Promise pattern.\r\n\r\nWhat if you want to pass a value from `get` to another function to operate on? A simple way to do this is to add a return statement which shares a value down the chain.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction give(val) {\r\n\treturn 'so extremely ' + val;\r\n}\r\n\r\nevenOdds().then(give, throwOut).then(get, throwOut);\r\n</pre>\r\n\r\n##Promise Land\r\n\r\nSo we are now passing a series of asynchronous functions through the Promise interface; this doesn't seem right. It doesn't seem right because we are in the Promise Land and all code in Promise Land is clean and beautiful. What I like about the Promise object is that\r\n\r\nA more readable homogenous way of doing it is to pass a promise generator through a `then` statement.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction got(value) {\r\n    return new Promise(function (resolve, reject) {\r\n        if (value) {\r\n            value = 'so extremely ' + value;\r\n            resolve(value);\r\n        } else {\r\n            reject('sorry');\r\n        }\r\n    });\r\n}\r\n\r\nevenOdds().then(got).then(give, throwOut);\r\n</pre>\r\n\r\n##Geolocation Method\r\n\r\nHTML5 has a native function [getCurrentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) to acquire geolocation data from a particular piece of hardware running a browser such as a laptop or mobile device. You can test your browser's ability use the HTML5 geolocation service with this [demo app](https://mdn.mozillademos.org/en-US/docs/Web/API/Geolocation/Using_geolocation$samples/Geolocation_Live_Example?revision=635775) provided by Mozilla.\r\n\r\nIn order to get location data from a device we use the asynchronous method `getCurrentPosition` which is called on the `navigator.geolocation` object and takes two callbacks `success` and `error`. [Callbacks](http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/) are functions that get passed into a host function in order to be called after some operations.\r\n\r\nThe Callback pattern is perhaps the most widely used design for asynchronous code. The essential mechanism of passing a function as another functions parameter is the fundamental way to interact with events that are non blocking. In fact, the first argument of [setTimeout](#asynchronous_code) can be considered a callback function for all intensive purposes. What's different is that `getCurrentPosition`takes an optional second callback, `error`, which is triggered if `getCurrentPosition` can't get geolocation data for the device it is running on.\r\n\r\n<pre class=\"prettyprint\">\r\nnavigator.geolocation.getCurrentPosition(success, error, options)\r\n</pre>\r\n\r\nSo now let's implement a `find` method and define a `success` and `error` function with some standard `options` for the output data.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction find() {\r\n\tnavigator.geolocation.getCurrentPosition(success, error, options);\r\n}\r\n\r\nfunction success(position) {\r\n\tconsole.log(\"Your current position is;\");\r\n    console.log(position.coords.latitude, position.coords.longitude);\r\n}\r\n\r\nfunction error() {\r\n    alert(\"Sorry, no position available.\");\r\n}\r\n\r\n// These are some standard options, it's actually not required\r\n// to provide the parameter of options.\r\nvar options = {\r\n    enableHighAccuracy: true,\r\n    maximumAge        : 30000,\r\n    timeout           : 27000\r\n};\r\n</pre>\r\n\r\nIf you enter `find();` in your developer's console you will get an output of your current location assuming you are on a the modern browser and have given it permission to check location.\r\n\r\nOur next challenge will be to take the latitude and longitude coordinates and turn that data into a physical address. Before we do this we are going to turn the `find` function in to a Promise in preparation of chaining the two functions together.\r\n\r\n\r\n\r\n\r\n##Geolocation Promise\r\n\r\nFirst off we'll create a Promise constructor for the geolocation service. If you recall the function to acquire geolocation data takes a `success` and `error` callback.\r\n\r\n<pre class=\"prettyprint\">\r\nnavigator.geolocation.getCurrentPosition(success, error, options)\r\n</pre>\r\n\r\nThis makes it easy to pipe into a Promise as `success` and `error` correspond to `resolve` and `reject`. For the sake of simplicity we will ignore the `options` argument.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction geoLocate() {\r\n    return new Promise(function(resolve, reject) {\r\n        navigator.geolocation.getCurrentPosition(resolve, reject);\r\n    });\r\n}\r\n</pre>\r\n\r\nLet's create a function that turns the geolocation object into latitude and longitude and wrap that function into a Promise.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction getCoordinates(position) {\r\n    return new Promise(function(resolve, reject) {\r\n        if (position) {\r\n            coords = [position.coords.latitude, position.coords.longitude];\r\n            resolve(coords);\r\n        } else {\r\n            reject(position);\r\n        }\r\n    });\r\n}\r\n</pre>\r\n\r\nNow let's create a fresh logging function `grab` to display the result and for good measure we'll recycle `throwOut` so we have an error function to pass.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction grab(val) {\r\n\tconsole.log(val);\r\n}\r\n\r\nfunction throwOut(value) {\r\n\tconsole.log(\"so wrong \" + value);\r\n}\r\n\r\ngeoLocate().then(getCoordinates).then(grab, throwOut);\r\n</pre>\r\n\r\n##Reverse Geocoding\r\n\r\nReverse Geocoding is the process of getting a physical address from latitude and longitude coordinates.\r\nWe are going to use the [Google Maps JavaScript API](https://developers.google.com/maps/documentation/javascript/) to perform the [Reverse Geocoding](https://developers.google.com/maps/documentation/javascript/examples/geocoding-reverse).\r\n\r\nTo start with you have to include the script that contains the Google Maps Javascript code for connection to the API.\r\n\r\n<pre class=\"prettyprint\">\r\n<script type=\"text/javascript\" src=\"https://maps.googleapis.com/maps/api/js?sensor=false\"></script>\r\n</pre>\r\n\r\nThe Google Maps API is fairly extensive performing many services which we are only using a small portion of.\r\n\r\n<pre class=\"prettyprint\">\r\nfunction reverseGeocode(coords) {\r\n    var geocoder = new google.maps.Geocoder(),\r\n        coordinates = new google.maps.LatLng(coords[0], coords[1]),\r\n        setting = { 'latLng': coordinates };\r\n    geocoder.geocode(setting, function (results, status) {\r\n        if (status === 'OK') {\r\n            var address = (results[0].formatted_address);\r\n            console.log(address);\r\n        } else {\r\n            alert(status);\r\n        }\r\n    });\r\n}\r\n</pre>\r\n\r\nhttp://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/\r\nhttp://stackoverflow.com/questions/4862193/javascript-global-variables\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\r\nhttp://fuqua.io/blog/2014/02/native-javascript-promises-and-browser-apis/\r\n\r\n\"Function statement should only be done at the top level.\" - Douglass Crockford [Because of hoisting?]","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}